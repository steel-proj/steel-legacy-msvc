#include "lexer/lexer.h"
#include "parser/parser.h"
#include "parser/semantics/semantic_analyser.h"
#include "codegen/codegen.h"
#include "interpreter/interpreter.h"

#include <Windows.h>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <vector>
#include <memory>
#include <string>
#include <algorithm>

#include "lexer/token_utils.h"

#undef min
#undef max

static void enable_ansi_escape_codes() {
#ifdef _WIN32
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	if (hConsole != INVALID_HANDLE_VALUE) {
		DWORD mode;
		GetConsoleMode(hConsole, &mode);
		mode |= ENABLE_VIRTUAL_TERMINAL_PROCESSING;
		SetConsoleMode(hConsole, mode);
	}
#endif
}

static void print_errors(const std::vector<std::string>& src, const std::vector<error>& errors) {
	for (const auto& error : errors) {
		std::cerr << "\033[1;31mError: \033[0m"
			<< "\033[1m" << error.message << "\033[0m"
			<< " at \033[36mline " << error.pos.line << ", column " << error.pos.column << "\033[0m\n";

		if (error.pos.line > 0 && error.pos.line <= src.size()) {
			int start_line = std::max(1, (int)error.pos.line - 2);
			int end_line = error.pos.line;
			int line_num_width = std::to_string(src.size()).size();

			for (int i = start_line; i <= end_line; ++i) {
				const auto& code_line = src[i - 1];

				std::cerr << "\033[2m" << std::setw(line_num_width) << i << " | " << "\033[0m" << code_line << "\n";

				if (i == error.pos.line) {
					std::cerr << std::setw(line_num_width) << " " << " | "
						<< std::string(error.pos.column - 1, ' ')
						<< "\033[1;31m^\033[0m HERE\n";
				}
			}
			std::cerr << std::endl;
		}
		else {
			std::cerr << "\033[1;31mLine number out of range.\033[0m\n";
		}
	}
}

static std::vector<std::string> readsrc(std::string path) {
	std::vector<std::string> lines;
	std::ifstream file(path);
	if (file.is_open()) {
		std::string line;
		while (std::getline(file, line)) {
			std::string nline = "";
			for (char c : line) {
				if (c == '\t') {
					nline += "    ";
				}
				else {
					nline += c;
				}
			}
			lines.push_back(nline);
		}
		file.close();
	}
	else {
		std::cerr << "Error: Could not open file " << path << std::endl;
	}
	return lines;
}

int main(int argc, char** argv) {
	bool interpreter_mode = true;
	bool print_tokens = false;
	bool print_tokenized_input = true;
	bool print_ast = false;
	enable_ansi_escape_codes();

	std::string input_path;
	if (input_path.empty()) {
		if (argc < 2) {
			std::cout << "Source file: ";
			std::getline(std::cin, input_path);
		}
		else {
			input_path = argv[1];
		}
		if (input_path.empty()) {
			std::cerr << "Error: No source file provided." << std::endl;
			std::cin.get();
			return 1;
		}
	}

	std::string input("");
	std::vector<std::string> lines = readsrc(input_path);
	for (std::string line : lines) {
		input += line + "\n";
	}
	
	std::cout << std::endl;

	lexer lexer(input);
	std::vector<token> tokens = lexer.tokenize();
	if (lexer.has_errors()) {
		print_errors(lines, lexer.get_errors());
		std::cin.get();
		return 1;
	}
	if (print_tokens) {
		for (int i = 0; i < tokens.size(); i++) {
			std::cout << "Token: \"" + tokens[i].value + "\", Type: \"" + to_string(tokens[i].type) + "\", Line: " << tokens[i].pos.line << ", Column: " << tokens[i].pos.column << std::endl;
		}
		std::cout << std::endl;
	}

	if (print_tokenized_input) std::cout << "Input:\n" + get_colored_representation(tokens) + "\n" << std::endl;

	parser parser(tokens);
	auto prg = std::make_shared<program>();
	parser.parse(prg);

	if (parser.has_errors()) {
		print_errors(lines, parser.get_errors());
		std::cin.get();
		return 1;
	}

	/*codegen codegen(prg);
	std::vector<unsigned char> bytecode = codegen.generate();
	std::cout << "Generated bytecode:\n";
	for (int i = 0; i < bytecode.size(); i++) {
		std::cout << std::hex << static_cast<int>(bytecode[i]) << " ";
	}
	std::cout << std::endl;
	std::cout << "Generated pseudo:\n" << codegen.generate_pseudo() << std::endl;*/

	std::shared_ptr<symbol_table> sym_table = std::make_shared<symbol_table>();
	interpreter interpreter(prg, sym_table);
	if (interpreter_mode) {
		// add built-ins
		interpreter.add_builtin_function(
			"Print",
			to_data_type(TT_VOID),
			{ std::make_shared<variable_decleration>(to_data_type(TT_STRING), "message") }
		);
		interpreter.add_builtin_function(
			"Print",
			to_data_type(TT_VOID),
			{ std::make_shared<variable_decleration>(to_data_type(TT_INT), "message") }
		);
		interpreter.add_builtin_function(
			"Print",
			to_data_type(TT_VOID),
			{ std::make_shared<variable_decleration>(to_data_type(TT_FLOAT), "message") }
		);
	}

	semantic_analyser analyser(prg, sym_table);
	analyser.analyse();

	if (analyser.has_errors()) {
		print_errors(lines, analyser.get_errors());
		std::cin.get();
		return 1;
	}

	if (print_ast) std::cout << "Final AST:\n" + prg->string() << std::endl;

	interpreter.begin_execution();

	std::cin.get();
}